############################################# WATCHING 

freeCodeCamp 1:05/


############################################# Orders of Growth



O(1) Constant
0(log n) Logarithmic
O(n) Linear
O(n log n) Linear  arithmic  
-----
O(n2) Quadratic
O(n3) Cubic
 

############################################# O(n2)

- usually a for loop with nested is considered O(n2)

############################################# O(n3)


############################################# Logarithm

- how many time do i multiply a base by itself to get a target number?

formally if a^b = x, then log_a(x) = b

 ex. base(10) 10^3 = 1000 => log10(1000) = 3

 so log is how many time do i need to multiply myseft to achieve the ANSWER

 log2(32) = 5 because 
 2x1= 2= 1
 2x2 = 4 = 2
 2x4 = 8 = 3
 2x8 = 16 = 4
 2x16 = 32 = 5


 ################################## Orders of Growth 

O(1) constant 
O(log n) logarithmic
O( n  ) linear
O( n log n) linearithmic
O(n2) quadratic
O(n3) qubic 
O(2n) exponential
O(!n) factorial



################################## O (log n) Logarithmic 

- check the file for sample function. code/logarithmic/logarithmic_sample

n = 8
8/2 = 4

n = 4
4/2 = 2

n = 2 
2/2 = 1

as you can see it was loop 3 times  
so log2^8 = 3 

- decreasing the n until 0 and matches the 
output considered log n

binary search and 0(log n)


- so i think if you are reducing the size of the array you can say it is


################################## O (n log n) Linear arithmic 


### Explanation for nlon a.py
n = 4 

4/2=2 -> log(1) -> log(2) -> log(3) -> log(4)

nextloop

n=2 
2/2=1 -> log(1) -> log(2) -> log(3) -> log(4)

- in this problem we want to keep the original value of n so we stored it in y
- we can see that every time we divide N we still proceed to have another loop inside

the top level loop is O(log n)
-  log2^4
-  log2^4 = 2
- 2^2= 4

- inside the loop we get linear since it grows depending on n 

################################## To understand the complexity of Merge Sort 


[6,1,23,3] we usually half them 

mergeSort([6,1]) mergeSort([23,3])

mergeSort([6]) , mergeSort([1]) , mergeSort([23]) , mergeSort([3])


Log2^=4
2^2 = 4 
meaning we will have 2 levels or recursion

since every level needs to touch the merege of function which is O(n)

which is ( n * log n)
0(4 * Log2^4)
O(4 * 2 )

meaning for every level which is 2 
we need to


################################## fib & exponential complexity 



################################## O(n!)

- look at the code in factorial/f.py 

if you put f(3) the out put for displaying "*****" will be 6 times look at the image/exponential_sample_1



################################## Space complexity and mistake